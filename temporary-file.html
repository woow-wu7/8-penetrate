<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="button">button</button>

    <script>
      // -----------------------------------------
      // 1 new
      function Fn(name, age) {
        this.name = name;
        this.age = age;
      }

      function _new(cons, ...params) {
        const obj = Object.create(cons.prototype);

        const res = cons.apply(obj, params);

        return res instanceof Object ? res : obj;
      }
      const res1 = _new(Fn, "woow_wu7", 20);
      console.log("res1: ", res1);
      const res2 = new Fn("woow_wu7", 20);
      console.log("res2: ", res2);

      // -----------------------------------------
      // 2 Object.create()
      const obj1 = { name: "woow_wu7" };
      function _create(obj) {
        function Temporary() {}
        Temporary.prototype = obj;
        Temporary.prototype.constructor = Temporary;

        return new Temporary();
      }
      const res3 = Object.create(obj1);
      console.log("res3: ", res3.name);
      const res4 = _create(obj1);
      console.log("res4: ", res4.name);

      // -----------------------------------------
      // 3 bind
      function Fn2(name, age) {
        this.name = name;
        this.age = age;
        return this.age + this.name;
      }
      const obj2 = { name: "woow_wu7" };

      Function.prototype._bind = function (obj, ...rest1) {
        const context = obj ? obj : globalThis;
        const self = this;

        const resFn = function (...rest2) {
          const totalParameters = [...rest1, ...rest2];
          return self.apply(this instanceof self ? this : context, totalParameters);
        };
        resFn.prototype = Object.create(self.prototype);

        return resFn;
      };
      const resfn1 = Fn2.bind(obj2, "woow_wu7");
      const res5 = resfn1(20);
      console.log("res5: ", res5);
      const resfn2 = Fn2._bind(obj2, "woow_wu8");
      const res6 = resfn2(21);
      console.log("res6: ", res6);
      const res7 = new resfn1(20);
      console.log("res7: ", res7);
      const res8 = new resfn2(21);
      console.log("res8: ", res8);

      // -----------------------------------------
      // 4 call
      const obj3 = { name: "woow_wu7" };
      function Fn3(age) {
        return this.name + age;
      }
      Function.prototype._call = function (obj, ...rest) {
        const context = obj ? obj : globalThis;
        context.fn = this;
        const res = context.fn(...rest);
        Reflect.deleteProperty(context, "fn");
        return res;
      };
      const ares = Fn3.call(obj3, 20);
      console.log("ares: ", ares);
      const ares2 = Fn3._call(obj3, 20);
      console.log("ares2: ", ares2);

      // -----------------------------------------
      // 5 instanceof
      function _instanceof(obj, Fn) {
        const left = Object.getPrototypeOf(obj);
        const right = Fn.prototype;
        while (left) {
          if (left === right) return true;
          left = Object.getPrototypeOf(left);
        }
        return false;
      }
      function Fn33() {}
      const fn33 = new Fn33();
      const aaa = fn33 instanceof Fn33;
      console.log("aaa: ", aaa);
      const bbb = _instanceof(fn33, Fn33);
      console.log("bbb: ", bbb);

      // -----------------------------------------
      // 6 shuffle
      const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      function shuffle(arr) {
        const _arr = JSON.parse(JSON.stringify(arr));
        return _arr.sort(() => Math.random() - 0.5);
      }
      const resShuffle = shuffle(arr);
      console.log("resShuffle: ", resShuffle);

      // -----------------------------------------
      // 7
      // http 1.0 - 无状态 无连接
      // http 1.1 - 长链接 管道化 缓存 断点续传
      // - 长链接: 响应头Connection: Keep-Alive 响应头Keep-Alive: max timeout
      // - 管道化: 多个请求可以并行发出，但是响应需要按序返回
      // - 缓存: Cache-Control: no-cache public/private  maxage  // expires
      // - 断点续传: 请求头Range 响应头Content-Range
      // http 2.0
      // - 二进制分帧
      // - 头部压缩
      // - 多路复用
      // - 服务端推送

      // -----------------------------------------
      // 8
      // Why the http need the three shake hands.
      // - 第一次: 服务端能确定自己的接收能力正常，客户端的发送能力正常
      // - 第二次: 客户端能确定自己的发送接收能力正常，服务端的接收发送能力正常，但是服务端不能确定客户端的接收能力是否正常
      // - 所以需要第三次握手

      // -----------------------------------------
      // 9 证书扭转
      // - 1. 服务器把自己的 公钥 给证书结构
      // - 2. 证书机构用自己的 私钥 加密服务器的 公钥 ,然后生成公钥证书
      // - 3. 证书结构 -> 服务器 -> 客户端
      // - 4. 客户端用内置在浏览器中的 ( 证书机构的-公钥 ) 去解 ( 用证书机构-私钥-加密服务器公钥生成的公钥证书 )，表明合法有效的网站，
      //      - 解开后会得到 服务器的公钥，
      //      - 然后用 服务器公钥 去加密 对称通信时所需要的 密钥
      // - 5. 然后服务器收到后，就可以用自己的 私钥 去解，得到 对称通信时所需要的 密钥
      // - 6. 之后双方就可以用 对称密钥 进行通讯加密了

      // -----------------------------------------
      // 10
      // 影响回流 reflow 的有哪些？
      // - 1. 页面初次加载
      // - 2. 位置 大小
      // - 3. 添加 删除
      // - 4. 显示 隐藏
      // - 5. fontsize
      // - 6. 激发 伪类

      // -----------------------------------------
      // 11
      // 只影响 repaint 的有哪些？
      // - 1. transform
      // - 2. opacity
      // - 3. will-change
      // - 4. filter

      // -----------------------------------------
      // 12
      // http报文
      // - 1. http报文 = 报文首部 + 空行 + 报文主体
      // -- 请求报文首部 = 请求行[HTTP方法+URI+http版本 ] + 请求头
      // -- 响应报文首部 = 响应行[http版本+状态码+原因短语] + 响应头

      // -----------------------------------------
      // 13 throttle
      const button = document.querySelector("button");
      const fn100 = () => {
        console.log("123", 123);
      };

      const clickListener = (fn, delay) => {
        let isRun = true;

        const closureFn = () => {
          console.log("2", 2);
          if (!isRun) return;
          isRun = false;

          const timer = setTimeout(() => {
            fn();
            isRun = true;
            window.clearTimeout(timer);
          }, delay);
        };

        return closureFn;
      };
      button?.addEventListener(
        "click",
        (e) => {
          console.log("0", 0);
          return clickListener(fn100, 100);
        },
        false
      );
    </script>
  </body>
</html>
