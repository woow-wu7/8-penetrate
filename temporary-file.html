<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="throttle">throttle</button>
    <button id="debounce">debounce</button>

    <script>
      // -----------------------------------------
      // 1 new
      function Fn(name, age) {
        this.name = name;
        this.age = age;
      }

      function _new(cons, ...params) {
        const obj = Object.create(cons.prototype);

        const res = cons.apply(obj, params);

        return res instanceof Object ? res : obj;
      }
      const res1 = _new(Fn, "woow_wu7", 20);
      console.log("res1: ", res1);
      const res2 = new Fn("woow_wu7", 20);
      console.log("res2: ", res2);

      // -----------------------------------------
      // 2 Object.create()
      const obj1 = { name: "woow_wu7" };
      function _create(obj) {
        function Temporary() {}
        Temporary.prototype = obj;
        Temporary.prototype.constructor = Temporary;

        return new Temporary();
      }
      const res3 = Object.create(obj1);
      console.log("res3: ", res3.name);
      const res4 = _create(obj1);
      console.log("res4: ", res4.name);

      // -----------------------------------------
      // 3 bind
      function Fn2(name, age) {
        this.name = name;
        this.age = age;
        return this.age + this.name;
      }
      const obj2 = { name: "woow_wu7" };

      Function.prototype._bind = function (obj, ...rest1) {
        const context = obj ? obj : globalThis;
        const self = this;

        const resFn = function (...rest2) {
          const totalParameters = [...rest1, ...rest2];
          return self.apply(this instanceof self ? this : context, totalParameters);
        };
        resFn.prototype = Object.create(self.prototype);

        return resFn;
      };
      const resfn1 = Fn2.bind(obj2, "woow_wu7");
      const res5 = resfn1(20);
      console.log("res5: ", res5);
      const resfn2 = Fn2._bind(obj2, "woow_wu8");
      const res6 = resfn2(21);
      console.log("res6: ", res6);
      const res7 = new resfn1(20);
      console.log("res7: ", res7);
      const res8 = new resfn2(21);
      console.log("res8: ", res8);

      // -----------------------------------------
      // 4 call
      const obj3 = { name: "woow_wu7" };
      function Fn3(age) {
        return this.name + age;
      }
      Function.prototype._call = function (obj, ...rest) {
        const context = obj ? obj : globalThis;
        context.fn = this;
        const res = context.fn(...rest);
        Reflect.deleteProperty(context, "fn");
        return res;
      };
      const ares = Fn3.call(obj3, 20);
      console.log("ares: ", ares);
      const ares2 = Fn3._call(obj3, 20);
      console.log("ares2: ", ares2);

      // -----------------------------------------
      // 5 instanceof
      function _instanceof(obj, Fn) {
        const left = Object.getPrototypeOf(obj);
        const right = Fn.prototype;
        while (left) {
          if (left === right) return true;
          left = Object.getPrototypeOf(left);
        }
        return false;
      }
      function Fn33() {}
      const fn33 = new Fn33();
      const aaa = fn33 instanceof Fn33;
      console.log("aaa: ", aaa);
      const bbb = _instanceof(fn33, Fn33);
      console.log("bbb: ", bbb);

      // -----------------------------------------
      // 6 shuffle
      const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      function shuffle(arr) {
        const _arr = JSON.parse(JSON.stringify(arr));
        return _arr.sort(() => Math.random() - 0.5);
      }
      const resShuffle = shuffle(arr);
      console.log("resShuffle: ", resShuffle);

      // -----------------------------------------
      // 7
      // http 1.0 - 无状态 无连接
      // http 1.1 - 长链接 管道化 缓存 断点续传
      // - 长链接: 响应头Connection: Keep-Alive 响应头Keep-Alive: max timeout
      // - 管道化: 多个请求可以并行发出，但是响应需要按序返回
      // - 缓存: Cache-Control: no-cache public/private  maxage  // expires
      // - 断点续传: 请求头Range 响应头Content-Range
      // http 2.0
      // - 二进制分帧
      // - 头部压缩
      // - 多路复用
      // - 服务端推送

      // -----------------------------------------
      // 8
      // Why the http need the three shake hands.
      // - 第一次: 服务端能确定自己的接收能力正常，客户端的发送能力正常
      // - 第二次: 客户端能确定自己的发送接收能力正常，服务端的接收发送能力正常，但是服务端不能确定客户端的接收能力是否正常
      // - 所以需要第三次握手

      // -----------------------------------------
      // 9 证书扭转
      // - 1. 服务器把自己的 公钥 给证书结构
      // - 2. 证书机构用自己的 私钥 加密服务器的 公钥 ,然后生成公钥证书
      // - 3. 证书结构 -> 服务器 -> 客户端
      // - 4. 客户端用内置在浏览器中的 ( 证书机构的-公钥 ) 去解 ( 用证书机构-私钥-加密服务器公钥生成的公钥证书 )，表明合法有效的网站，
      //      - 解开后会得到 服务器的公钥，
      //      - 然后用 服务器公钥 去加密 对称通信时所需要的 密钥
      // - 5. 然后服务器收到后，就可以用自己的 私钥 去解，得到 对称通信时所需要的 密钥
      // - 6. 之后双方就可以用 对称密钥 进行通讯加密了

      // -----------------------------------------
      // 10
      // 影响回流 reflow 的有哪些？
      // - 1. 页面初次加载
      // - 2. 位置 大小
      // - 3. 添加 删除
      // - 4. 显示 隐藏
      // - 5. fontsize
      // - 6. 激发 伪类

      // -----------------------------------------
      // 11
      // 只影响 repaint 的有哪些？
      // - 1. transform
      // - 2. opacity
      // - 3. will-change
      // - 4. filter

      // -----------------------------------------
      // 12
      // http报文
      // - 1. http报文 = 报文首部 + 空行 + 报文主体
      // -- 请求报文首部 = 请求行[HTTP方法+URI+http版本 ] + 请求头
      // -- 响应报文首部 = 响应行[http版本+状态码+原因短语] + 响应头

      // -----------------------------------------
      // 13 throttle
      const button = document.getElementById("throttle");
      const fn100 = () => {};
      const clickListener = (fn, delay) => {
        let isRun = true;
        const closureFn = (e) => {
          if (!isRun) return;
          isRun = false;
          const timer = setTimeout(() => {
            console.log("e", e);
            fn();
            isRun = true;
            window.clearTimeout(timer);
          }, delay);
        };
        return closureFn;
      };
      button.addEventListener("click", clickListener(fn100, 2000), false);

      // -----------------------------------------
      // 14 debounce
      const debounceButton = document.getElementById("debounce");
      const debounce = (fn, delay) => {
        let timer;
        return () => {
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => {
            fn();
          }, delay);
        };
      };
      debounceButton.addEventListener(
        "click",
        debounce(() => {
          console.log("debounce");
        }, 1000),
        false
      );

      // -----------------------------------------
      // 15 Sort - bubble sort algorithm.
      const arrFBubble = [9, 3, 8, 5, 1, 2, 7, 4, 6];
      const bubbleSort = (arr) => {
        const copyArr = [...arr];
        const len = copyArr.length;
        for (let i = 0; i < len - 1; i++) {
          for (let j = 0; j < len - 1 - i; j++) {
            if (copyArr[j] > copyArr[j + 1]) {
              [copyArr[j], copyArr[j + 1]] = [copyArr[j + 1], copyArr[j]];
            }
          }
        }
        return copyArr;
      };
      const resBubble = bubbleSort(arrFBubble);
      console.log("resBubble: ", resBubble);

      // -----------------------------------------
      // 16 Sort - selection sort algorithm.
      const arrFSelection = [9, 3, 8, 5, 1, 2, 7, 4, 6];
      const selectionSort = (arr) => {
        const _arr = [...arr];
        const len = _arr.length;
        for (let i = 0; i < len; i++) {
          let min = i;
          for (let j = i + 1; j < len; j++) {
            if (_arr[j] < _arr[min]) {
              min = j;
            }
          }
          [_arr[min], _arr[i]] = [_arr[i], _arr[min]];
        }
        return _arr;
      };
      const resSelection = selectionSort(arrFSelection);
      console.log("resSelection: ", resSelection);

      // -----------------------------------------
      // 17 Insert - selection sort algorithm.
      const arrFInsertion = [9, 3, 8, 5, 1, 2, 7, 4, 6];
      const insertionSort = (raw) => {
        const arr = [...raw];
        const len = arr.length;
        for (let i = 1; i < len; i++) {
          const cache = arr[i];
          let j = i - 1;
          while (j >= 0 && arr[j] > cache) {
            arr[j + 1] = arr[j];
            j--;
          }
          arr[j + 1] = cache;
        }
        return arr;
      };
      const resInsertion = insertionSort(arrFInsertion);
      console.log("resInsertion: ", resInsertion);

      // -----------------------------------------
      // 18 Quick - Quick sort algorithm.
      const arrFQuick = [9, 3, 8, 5, 1, 2, 7, 4, 6];
      const quickSort = (raw) => {
        const arr = [...raw];
        const len = arr.length;
        if (len <= 1) return raw;
        const left = [];
        const right = [];
        const middle = [];
        const pivotIndex = Math.floor(Math.random() * len);
        const pivot = arr[pivotIndex];
        for (let i = 0; i < len; i++) {
          const cur = arr[i];
          if (cur > pivot) right.push(cur);
          if (cur < pivot) left.push(cur);
          if (cur === pivot) middle.push(cur);
        }
        return quickSort(left).concat(middle, quickSort(right));
      };
      const resQuick = quickSort(arrFQuick);
      console.log("resQuick: ", resQuick);
    </script>
  </body>
</html>
