![koa源码.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c694c0d7a1e649cfbe22880d7f111b65~tplv-k3u1fbpfcp-watermark.image?)

# 导航

[[react] Hooks](https://juejin.im/post/6844904045342113799)

[[封装 01-设计模式] 设计原则 和 工厂模式(简单抽象方法) 适配器模式 装饰器模式](https://juejin.cn/post/6950958974854234119)  
[[封装 02-设计模式] 命令模式 享元模式 组合模式 代理模式](https://juejin.cn/post/6950958974854234119)

[[React 从零实践 01-后台] 代码分割](https://juejin.im/post/6879020830253285384)  
[[React 从零实践 02-后台] 权限控制](https://juejin.im/post/6881481205657632781)  
[[React 从零实践 03-后台] 自定义 hooks](https://juejin.im/post/6887132776512880654)  
[[React 从零实践 04-后台] docker-compose 部署 react+egg+nginx+mysql](https://juejin.im/post/6892390655126241287)  
[[React 从零实践 05-后台] Gitlab-CI 使用 Docker 自动化部署](https://juejin.cn/post/6897884843275714567)

[[源码-webpack01-前置知识] AST 抽象语法树](https://juejin.im/post/6844904115265339406)  
[[源码-webpack02-前置知识] Tapable](https://juejin.im/post/6844904115269550087)  
[[源码-webpack03] 手写 webpack - compiler 简单编译流程](https://juejin.im/post/6844903973002936327)  
[[源码] Redux React-Redux01](https://juejin.im/post/6844904137952329742)  
[[源码] axios ](https://juejin.im/post/6844904147532120072)  
[[源码] koa](https://juejin.cn/post/7008056344540348453)  
[[源码] vuex ](https://juejin.im/post/6844904166293241863)  
[[源码-vue01] data 响应式 和 初始化渲染 ](https://juejin.im/post/6844904181094957069)  
[[源码-vue02] computed 响应式 - 初始化，访问，更新过程 ](https://juejin.im/post/6844904184035147790)  
[[源码-vue03] watch 侦听属性 - 初始化和更新 ](https://juejin.im/post/6844904186652409863)  
[[源码-vue04] Vue.set 和 vm.$set](https://juejin.im/post/6844904190918000654)  
[[源码-vue05] Vue.extend](https://juejin.im/post/6844904201944825863)

[[源码-vue06] Vue.nextTick 和 vm.$nextTick](https://juejin.im/post/6847902219107303438)

[[源码-react01] ReactDOM.render01](https://juejin.cn/post/6993980489463758855)  
[[源码-react02] 手写 hook 调度-useState 实现](https://juejin.cn/post/6998452866369191972)

[[部署 01] Nginx](https://juejin.im/post/6844904095464030215)  
[[部署 02] Docker 部署 vue 项目](https://juejin.im/post/6844904099024994312)  
[[部署 03] gitlab-CI](https://juejin.im/post/6844904103944912904)

[[数据结构和算法 01] 二分查找和排序](https://juejin.cn/post/6907145602400780296/)

[[深入 01] 执行上下文](https://juejin.im/post/6844904046050934792)  
[[深入 02] 原型链](https://juejin.im/post/6844904048873701389)  
[[深入 03] 继承](https://juejin.im/post/6844904050895372295)  
[[深入 04] 事件循环](https://juejin.im/post/6844904051562250254)  
[[深入 05] 柯里化 偏函数 函数记忆](https://juejin.im/post/6844904052879261710)  
[[深入 06] 隐式转换 和 运算符](https://juejin.im/post/6844904052937981959)  
[[深入 07] 浏览器缓存机制（http 缓存机制）](https://juejin.im/post/6844904053013479432)  
[[深入 08] 前端安全](https://juejin.im/post/6844904053235793927)  
[[深入 09] 深浅拷贝](https://juejin.im/post/6844904053764259854)  
[[深入 10] Debounce Throttle](https://juejin.im/post/6844904054330490894)  
[[深入 11] 前端路由](https://juejin.im/post/6844904054846390279)  
[[深入 12] 前端模块化](https://juejin.im/post/6844904056557682701)  
[[深入 13] 观察者模式 发布订阅模式 双向数据绑定](https://juejin.im/post/6844904058604486663)  
[[深入 14] canvas](https://juejin.im/post/6844904063029477389)  
[[深入 15] webSocket](https://juejin.im/post/6844904066808561677)  
[[深入 16] webpack](https://juejin.im/post/6844904070201753608)  
[[深入 17] http 和 https](https://juejin.im/post/6844904085750038542)  
[[深入 18] CSS-interview](https://juejin.im/post/6844904090644774926)  
[[深入 19] 手写 Promise](https://juejin.im/post/6844903823429861389)  
[[深入 20] 手写函数](https://juejin.im/post/6844904131577004040)  
[[深入 21] 数据结构和算法 - 二分查找和排序](https://juejin.cn/post/6907145602400780296/)  
[[深入 22] js 和 v8 垃圾回收机制](https://juejin.cn/post/6911192116651622413)  
[[深入 23] JS 设计模式 - 代理，策略，单例](https://juejin.cn/post/6918744081460002824)  
[[深入 24] Fiber](https://juejin.cn/post/6983570939342487565)  
[[深入 25] Typescript](https://juejin.cn/post/6999807282343051277)

[[前端学 java01-SpringBoot 实战] 环境配置和 HelloWorld 服务](https://juejin.cn/post/6927306093970325517)  
[[前端学 java02-SpringBoot 实战] mybatis + mysql 实现歌曲增删改查](https://juejin.cn/post/6929145638898794503)  
[[前端学 java03-SpringBoot 实战] lombok，日志，部署](https://juejin.cn/post/6930627377101979662)  
[[前端学 java04-SpringBoot 实战] 静态资源 + 拦截器 + 前后端文件上传](https://juejin.cn/post/6932097247735709709)  
[[前端学 java05-SpringBoot 实战] 常用注解 + redis 实现统计功能](https://juejin.cn/post/6933224825200574478)  
[[前端学 java06-SpringBoot 实战] 注入 + Swagger2 3.0 + 单元测试 JUnit5](https://juejin.cn/post/6934274450514771982)  
[[前端学 java07-SpringBoot 实战] IOC 扫描器 + 事务 + Jackson](https://juejin.cn/post/6935081135114289188)  
[[前端学 java08-SpringBoot 实战总结 1-7] 阶段性总结](https://juejin.cn/post/6960187616050282533)  
[[前端学 java09-SpringBoot 实战] 多模块配置 + Mybatis-plus + 单多模块打包部署](https://juejin.cn/post/6962752749993721892)  
[[前端学 java10-SpringBoot 实战] bean 赋值转换 + 参数校验 + 全局异常处理](https://juejin.cn/post/6965404539298168839)  
[[前端学 java11-SpringSecurity] 配置 + 内存 + 数据库 = 三种方式实现 RBAC](https://juejin.cn/post/6968003860522598436)  
[[前端学 java12-SpringSecurity] JWT](https://juejin.cn/post/6970598940479586334)  
[[前端学 java13-SpringCloud] Eureka + RestTemplate + Zuul + Ribbon](https://juejin.cn/post/6973100621205520392)

# (一) 前置知识

### (1) 一些单词

```
proper 非常 正确的 adj // properly 正确地 adv
dealing with 处理
expose 暴露 陈述
silent 沉默的 寂静
poll 轮询
stderr 标准错误

noop 空函数
```

### (2) koa 用到的 nodeJs 中的一些 api

```
1
http.createServer()
koa案列：koa.listen(3000) -> http.createServer -> server.listen(3000)
nodeApi：
  - http.createServer([options][, requestListener])
    - 参数
      - options：是一个配置对象，可选，一般不用配置
      - requestListener：请求监听函数，可选
    - 返回值
      - http.Server的新实例，返回的新实例上具有 listen() 方法
官方文档：http://nodejs.cn/api/http.html#http_http_createserver_options_requestlistener
---
案例：
const http = require('http');
const server = http.createServer((req, res) => {
  // 创建本地服务器来从其接收数据
  // req请求
  // res响应
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ // --- res.end()
    data: 'Hello World!'
  }));
});
server.listen(8000); // --------- server.listen()
```

```
2
process.nextTick
函数签名：process.nextTick(callback[, ...args])
作用：微任务 - 在同步方法执行完毕后，下一轮事件循环中的开始执行
特点：
  - 执行时机在同步任务之后，在异步任务宏任务setTimeout之前
  - 其实process.nextTick()会在node事件循环的各个周期优先执行
参数：
  - 1. callback回调函数
  - 2. args当调用callback时要传入的额外参数


3
node.js事件轮训机制 - 一共分为6个阶段
(1) timers 定时器阶段
- ( 计时 ) 和 ( 执行到点的定时器 )
(2) pending callbacks 阶段
- 执行某些系统操作的回调函数，比如 ( tcp错误类型 )
(3) idle, prepare 阶段
- 一些准备工作
(4) poll轮询阶段，是一个轮询队列
- 1. 如果 ( 轮询队列不为空 )，依次取出执行，直到 ( 轮询队列为空 ) 或者 ( 达到系统最大限制 )
- 2. 如果 ( 轮询队列为空 )
     - 1. 如果之前设置过 ( setImmediate ) 函数，则直接进入下一个阶段 ( check阶段 )
     - 2. 如果之前没有设置过setImmediate函数，则会在当前poll阶段 ( 等待 )
          - 直到 ( 轮询队列 ) 添加进了新的回调函数，那么就会进入(4)阶段1的判断，继续执行
          - 或者 ( 定时器 ) 到点了，也会进入下一个阶段 ( check阶段 )
(5) check 阶段
- 执行 ( setImmediate ) 回调函数
(6) close callbacks 阶段
- 执行 ( close ) 事件回调函数
-------> 注意点：process.nextTick() 会在nodejs事件轮询的 ( 任意阶段，优先执行 )


---
案例
console.log(1);  // 同步任务
setTimeout(() => console.log(2)); // timer阶段执行 - nodejs事件轮询的第 1 个阶段
setTimeout(() => console.log(8), 0); // timer阶段执行 - nodejs事件轮询的第 1 个阶段
process.nextTick((n) => console.log(n), 3); // --- 在 node.js 事件轮询的 ( 任意阶段，优先执行 )，即在同步任务执行完毕后，优先执行
setImmediate(() => console.log(4)); // check阶段执行 - nodejs事件轮询的第 5 个阶段
new Promise((resolve) => {
  console.log(5); // 同步任务
  resolve();
  console.log(7); // 同步任务
}).then((res) => console.log(6)); // --- 微任务
// 执行顺序 1 5 7 3 6 2 8 4
// 同步任务 1 5 7
// 异步任务(微任务) 3 6
// 异步任务(宏任务) 2 8 4
```

### (3) koa 的一些 api

```
1
const app = new Koa()

- 1
- 问题：app上有哪些属性？
- 回答：
app.env -----------> 环境变量 -> 默认是 NODE_ENV 或 'development'
app.keys ----------> 签名的cookie密钥数组
app.proxy ---------> 当真正的代理头字段将被信任时忽略 `.subdomains` 的 `app.subdomainOffset` 偏移量，默认为 2
app.proxyIpHeader -> 代理ip消息头
app.maxIpCount ----> 从代理ip消息头读取的最大ips，默认是0表示无限
- 2
- 问题：如何设置这些属性
- 回答：有两种方法
  - 1. 通过参数来设置： const app = new Koa({proxy: true})
  - 2. 动态来设置：app.proxy = true
```

```
2
context
- Koa Context 将 node 的 `request` 和 `response` 对象封装到单个对象中
- 每个请求都将创建一个 `Context`，并在中间件中作为接收器引用，或者 `ctx` 标识符
app.use(async ctx => {
  ctx; // 这是 Context
  ctx.request; // 这是 koa Request
  ctx.response; // 这是 koa Response
  ctx.req; // Node 的 `request` 对象
  ctx.res; // Node 的 `response` 对象
  ctx.state; // 推荐的命名空间，用于通过中间件传递信息和你的前端视图
  ctx.app; // 引用程序实例引用
});
```

### (4) koa 中间件的使用

- koa 应用程序
  - koa 应用程序是一个包含 ( `一组中间件函数` ) 的`对象`，按照类似 ( 堆栈 ) 的方式组织和执行
- 中间价
  - 中间件可以完成比如：`内容协商`，`缓存清理`，`代理支持`，`重定向`等
- **next()**
  - 当一个中间件调用 `next()`，则该`函数暂停`，并将控制传递给定义的 ( `下一个中间件` )
  - 当下游没有更多中间件执行后，( 堆栈将展开 ) 并且 ( 每个中间键恢复执行 ) 其上游行为

```
1
koa中间件的执行顺序
---
const Koa = require("./lib/application.js");
const app = new Koa();
app.use(async (ctx, next) => { console.log(1); await next(); console.log(2); });
app.use(async (ctx, next) => { console.log(3); await next(); console.log(4); });
app.use(async (ctx, next) => { console.log(5); ctx.body = "测试中间执行顺序"; });
app.listen(1000, () => 'app run 1000')
---
// 执行顺序为 1 3 5 4 2
// 原理：
// - 1. 当中间件函数中，执行了next()方法时，其实就是执行下一个中间件，递归的执行下去
// - 2. 当执行完next()，接着执行当前中间件函数中剩下的代码，顺序就是函数调用栈的顺序
// - 3. 其实就是洋葱模型
```

```
2
context对象中包含了哪些属性 - ( ctx对象 )
---
context.app -> app属性指的是const app = new Koa() 生成的koa实例
context.req
context.res
context.request
context.response
context.originalUrl
context.state
---
app.use(async (ctx, next) => { console.log(1); await next(); console.log(2) })
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39441e0bef8f4fe1ac127d5ef24a3a49~tplv-k3u1fbpfcp-watermark.image)

### (5) Object.create()

```
Obejct.create
---
const instanceObj = Object.create(prototypeObj)

1. 作用：以 ( 参数对象 ) 为 ( 原型 )，生成 ( 实例对象 )，实例对象完全继承参数对象的属性和方法
2. 注意点：生成的实例对象，( 实例对象本身没有任何属性和方法 )，只是继承了参数对象的所有属性和方法
3. 例子
const a = {name: []}
const b = Object.create(a)
b // {}
b.name === a.name // true
Object.getPrototypeof(b) === a // true

4. Object.create() 方法的模拟实现
- 实现原理：通过 ( 构造函数式继承 ) 来实现
function create(obj) {
    function F(){} // 声明一个构造函数
    F.prototype = obj // 将构造函数F的prototype赋值为obj，这样通过 new F() 生成的实例就能继承 obj 对象的属性和方法
    return new F() // 返回实例
}
```

### (6) 如何调试 koa 源码

- 本项目已经做好了调试配置，只需要执行 `cnpm run dev` 断点调试 `index.js` 文件即可
- [koa 源码分析-源码调试仓库地址](https://github.com/woow-wu7/7-koa-source-code-analysis)

```
1. 克隆koa源码：git clone git@github.com:koajs/koa.git
2. 安装依赖：cnpm install
3. 新建 index.js，并写入示例代码
4. 在 `vscode` 中选择 `运行和调试`， 新建 `launch.json` ，选择 `node`，并做如下配置
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "启动程序",
      "skipFiles": [
        "<node_internals>/**"
      ],
      "program": "${workspaceFolder}/index.js"
    }
  ]
}
5. 启动项目：node index.js
6. 在index.js中打断点，通过 `运行和调试` 菜单中的 `开始调试` 按钮进行断点吊饰即可
```

# (二) KOA 源码目录结构说明

```
1. 入口文件
- 在package.json中通过 `main` 属性得知入口文件是 `lib/application.js`

2. 核心文件
- 核心文件都在 `lib` 文件夹中
- lib/application.js --> 主要就是Koa类相关代码，即 new Koa()
- lib/context.js ------> 是contxt对象相关
- lib/request.js ------> request相关
- bli/response.js -----> response相关

3. 依赖
- koa-compose ---------> 处理中间件
- on-finished ---------> 主要作用：当 HTTP 请求关闭、完成或出错时执行回调
```

# (三) 源码主流程 - 中间件

```
1.
首先有这样一段代码
const Koa = require("./lib/application.js");
const app = new Koa();
app.use(async (ctx, next) => { console.log(1); await next(); console.log(2); });
app.use(async (ctx, next) => { console.log(3); await next(); console.log(4); });
app.use(async (ctx, next) => { console.log(5); ctx.body = "测试中间执行顺序"; });
app.listen(1000, () => 'app run 1000')
---
// 执行顺序为 1 3 5 4 2
// 原理：
// - 1. 当中间件函数中，执行了next()方法时，其实就是执行下一个中间件，递归的执行下去
// - 2. 当执行完next()，接着执行当前中间件函数中剩下的代码，顺序就是函数调用栈的顺序
// - 3. 其实就是洋葱模型
```

```
2.
const app = new Koa()
app.use()
app.listen()
对应源码如下
---
class Application extends Emitter {
  constructor(options) {}

  // ------------------------------- use
  use(fn) {
    this.middleware.push(fn);
    return this;
  }

  // ------------------------------- listen
  listen(...args) {
    const server = http.createServer(this.callback()); // http.createServer是node原生api
    return server.listen(...args);
  }

  // ------------------------------- callback
  callback() {
    const fn = compose(this.middleware);
    const handleRequest = (req, res) => {
      const ctx = this.createContext(req, res); // 创建context对象，包含request，resposne，req，res等属性
      return this.handleRequest(ctx, fn);
    };
    return handleRequest;
 }

  // ------------------------------- handleRequest
  handleRequest(ctx, fnMiddleware) {
    return fnMiddleware(ctx).then(handleResponse).catch(onerror);
    // 中间件的执行过程
    // 所以核心就是这个 fnMiddleware(ctx)
  }
}
```

```
3
fnMiddleware(ctx)
- fnMiddleware(ctx) 就是执行 const fn = compose(this.middleware) 返回的fn
- 而compose是依赖库 `koa-compose` ，具体代码如下
---

// ------------------------------------------------------------------------------------------------------------------- compose
// compose
// - 参数
//    - 中间价组成的数组，每个中间件必须是函数
// - 返回值
//    - 返回一个函数
function compose(middleware) {
  if (!Array.isArray(middleware))
    throw new TypeError("Middleware stack must be an array!"); // 参数必须是数组
  for (const fn of middleware) {
    if (typeof fn !== "function")
      throw new TypeError("Middleware must be composed of functions!"); // 每个中间件必须由函数组成
  }

  /**
   * @param {Object} context
   * @return {Promise}
   * @api public
   */

  return function (context, next) {
    // last called middleware #
    let index = -1;
    return dispatch(0);
    function dispatch(i) {
      // 调用时：dispatch(0)

      if (i <= index) {
        return Promise.reject(new Error("next() called multiple times"));
        // i <= index 证明next()方法被多次调用
        // dispatch(0)时得出: ( 0<=-1不成立 )
      }

      index = i;
      // 1
      // i = 0 --> index = i = 0

      let fn = middleware[i];
      // 1
      // middleware[0] 第一个中间件函数

      if (i === middleware.length) fn = next;
      // 当为最后一个中间件时，继续执行dispatch() --> fn=next=undefined --> return Promise.resolve()，
      // - next不存在，return Promise.resolve()
      // - next存在，则执行next(context, dispatch.bind(null, i+1))

      // fn不存在
      if (!fn) return Promise.resolve();

      // fn存在
      // 则继续往下执行
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
        // 返回Promise成功的结果 -> 即执行中间件，中间件返回值作为promise成功状态的结果值
        // 1
        // 中间件函数的结构
        // app.use(async (ctx, next) => { ... })
        // async (ctx, next) => {...}
        // 2
        // fn(context, dispatch.bind(null, i + 1)) ---> next() 其实就是这里的 dispatch() 函数 ---> i+1就是下一个中间件

        // 2022.04.11 添加一个问题
        // 问题：到底是什么是中间件中的next
        // 回答：
        // - 1. 中间件 app.use(async (ctx, next) => { ... })
        // - 2. next 就是上面的 dispatch 函数
        // - 3. 而 dispatch 又会去执行下一个中间件，不断重复，直到最后一个中间件
        // - 4. 还要注意 next() 调用的时机，如果next() 后面还有代码，在next()执行完后，还会回来继续执行

      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}
```

```
4
梳理中间件
- 调用顺序：app.listen() ---> callback() ---> handleRequest() ---> 中间件fn(ctx).then(handleResponse).catch(onerror)
- fnMiddleware = compose(this.middleware) = function (context, next) =>  dispatch(0)
---

中间件 - 具体的执行过程
1. fnMiddleware(ctx).then(handleResponse).catch(onerror)
2. (function (context, next) =>  dispatch(0)).then(handleResponse).catch(onerror)
3. dispatch(0).then(handleResponse).catch(onerror)
4. Promise.resolve(middlewareFn0(context, dispatch.bind(null,1)))
5. Promise.resolve(async(ctx, dispatch) => {... dispatch(1) ...})
6. 最终形态如下
const [fn1, fn2, fn3] = this.middleware()
const fnMiddleware = function(context, next) {
  return Promise.resolve(fn1(context, function next1() {
    return Promise.resolve(fn2(context, function next2() { // 每个中间件，如果存在next就return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))，不存在就 return Promise.resolve()
      return Promise.resolve(fn3(context, function next3() { // 最后一个中间件没有next函数了，因为已经是最后一个
        return Promise.resolve()
      }))
    }))
  }))
}

7. fnMiddleware() 执行的最终状态如下
- 7.1
app.use(async (ctx, next) => {
  console.log(1);
  await next();
  console.log(2);
});
app.use(async (ctx, next) => {
  console.log(3);
  await next();
  console.log(4);
});
app.use(async (ctx, next) => {
  console.log(5);
  ctx.body = "测试中间执行顺序";
});
- 7.2
fnMiddleware() => Promise.resolve(
  // fn1()
  console.log(1)
  await Promise.resolve( // next()
    // fn2()
    console.log(3)
    await Promise.resolve( // next()
      // fn3()
      console.log(5)
      return Promise.resolve()
    )
    console.log(4)
  )
  console.log(2)
)
.then(handleResponse)
.catch(onerror)

// 13542
```

# 源码分析仓库地址

- [koa 源码分析 - 仓库地址](https://github.com/woow-wu7/7-koa-source-code-analysis)
- [koa 源码分析 - 思维导图](https://github.com/woow-wu7/7-koa-source-code-analysis/blob/main/xmind/koa源码.png)

# 资料

koa 官网 https://koa.bootcss.com/  
koa 源码分析 https://juejin.cn/post/6998677014722904101  
川神 https://juejin.cn/post/6844904088220467213
