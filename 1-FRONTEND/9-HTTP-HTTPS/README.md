# HTTP

- https://juejin.cn/post/6844904085750038542

## 一些单词

```
tunnel 隧道 管道
patch 不定 修补
establish 建立 // 三次握手后客户端和服务端状态都变成了established

certificate 证书
cipher 密码
```

## (一) HTTP 方法

### (1.1) HTTP 有哪些请求方法

- HTTP1.0 定义了三种方法：GET，POST，HEAD
- HTTP1.1 定义了五种方法：PUT，PATCH，DELETE，OPTIONS，CONNECT

```
OPTIONS
- 用于获取目的资源所支持的 ( 请求方法 )
- 返回报文的 ( 报文首部 - 响应头 ) 中包含 ( Allow ) 字段，值是所支持的请求方法
- 响应头 Allow: GET,POST
- 应用: 比如 cors 设置跨域时，如果是非简单请求，就会先进行 options 请求
- 扩展: cors请求时，非简单请求的options请求有三个作用: 1.Origin表示的白名单 2.Access-Control-Request-Method会用的HTTP方法 3.Access-Control-Request-Headers允许的头信息


CONNECT
- 该方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）
- HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
```

### (1.2) GET 和 POST 的区别？

- 作用
  - GET 获取资源
  - POST 添加资源/更新资源
- 参数
  - GET 通过 query 传递参数
  - POST 通过 body 传递参数
  - `本质上 GET 和 POST 都能通过 query 和 body 传递数据`
- 幂等
  - GET 幂等
  - POST 非幂等
- 书签和缓存
  - GET 可以作为书签，能被浏览器和代理服务器缓存
  - POST 不能作为书签，不能被浏览器和代理服务器缓存
- TCP 数据包个数
  - GET 产生一个 TCP 数据包， POST 产生两个 TCP 数据包
  - GET: 浏览器会把 ( header 和 data ) 一并发送出去，服务器响应 200（返回数据）
  - POST: 浏览器( 先发送 header )，服务器响应 100 continue 表示继续请求，然后浏览器 ( 再发送 data )，服务器响应 200 ok（返回数据）

### (1.3) PUT 和 POST 的区别？

- 幂等性
  - PUT 是幂等的，即 连续调用一次或者多次的效果相同（无副作用）
  - POST 是非幂等的
- 资源
  - PUT 的 URI 指向是具体单一资源 -- 更新资源
  - POST 可以指向资源集合 --------- 新增资源
- 总结
  - POST 用于新增资源，非幂等，即多次提交会多次添加新资源
  - PUT 用于修改资源，幂等，每次提交都是修改成同样的内容，只争对单一资源

### (1.4) PUT 和 PATCH 的区别？

- 两者都可以 更新资源
- PATCH 是对资源进行 ( 局部更新 )，这样 PATCH 就会少提交一些 body 属性，减小报文大小
- patch 是补丁的意思，PATCH 是对 PUT 方法的补充

## (二) http1.0 和 http1.1 的区别？

- http1.0
  - 无状态
  - 无连接
- http1.0
  - 长连接
  - 管道化
  - 缓存
  - 断点续传

```HTTP1.0
HTTP1.0
---

(1) 无状态
1. 服务器不跟踪记录请求过的状态
2. 对于无状态的特性可以借助 ( cookie/session ) 机制来做 ( 身份认证 ) 和 ( 状态记录 )

(2) 无连接
无连接导致的性能缺陷主要有两种：
1. 无法复用链接: 每次发送请求，都需要进行tcp链接，即三次握手和四次挥手，使得网络的利用率极低
2. 对头阻塞: http1.0规定，在前一个请求响应到达之后，下一个请求才能发送，如果前一个请求阻塞，后面的就都会阻塞，从而造成对头阻塞
```

```HTTP1.1
HTTP1.1
---

(1) 长连接
- HTTP1.1默认保持长连接，数据传输完成，保持tcp链接不断开，继续使用这个通道传输数据
- 响应头：Connection: Keep-Alive
- 响应头：Keep-Alive: timeout=5, max=1000
          - timeout：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）
          - max：在连接关闭之前，在此连接可以发送的请求的最大值

(2) 管道化
- http1.0 ( 无链接 )
    - 请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
- http1.1 ( 管道化 )
    - 请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
- 虽然管道化一次可以发送多个请求，但响应仍然是顺序返回，仍然无法解决对头阻塞的问题，TCP传输层仍然会阻塞

(3) 缓存处理
- HTTP1.1新增 Cache-Control 字段
    - http1.0  =>  expires           => 是一个绝对时间点，用GMT时间格式
    - http1.1  =>  Cache-Control     => 是一个相时时间段，以秒为单位，可以设置 max-age private no-cache 等
- Cache-control: no-cache,private,max-age=123123
    - no-cache：不使用强缓存，使用协商缓存
    - max-age: 一个时间段，单位是秒
    - public：允许所有服务器缓存该资源
    - private：表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源
               对于包含用户个人信息的文件，可以设置private
- Expires 和 Cache-Control 对比
    - 如果同时开启，Cache-Control 的优先级高于 Expires
    - expires是一个用GMT时间表示的时间点，Cache-Control是用秒表示的时间段(一个差值)，都是和浏览器本地时间做对比
    - Cache-Control 比 Expires 更加精确
    - Cache-Control 比 Expires 的优先级更高，都设置时，Cache-Control 生效

(4) 断点续传
- 请求头：Range
- 响应头：Content-Range
- 原理
    - 在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载
    - 如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率
- 案例：
    - Range: bytes=0-801
    - Content-Range: bytes 0-800/801
```

## (三) http2.0

- 二进制分帧
- 多路复用：在共享 TCP 链接的基础上同时发送请求和响应
- 头部压缩
- 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求

```
HTTP2.0

(1) 二进制分帧
- 将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码

(2) 多路复用
- 基于二进制分帧
- 在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来
- 比如：一个页面有三个http请求，在HTTP1.0时需要发三次http请求，而HTTP2.0只需要发送一次HTTP请求，将之前的三次分层不同的stream，乱序发送

(3) 头部压缩
- 将http中的头部中的key:value的纯文本，在两端做了一个映射表，发送的时候只需要记录key就可以了
```

## (四) HTTP 的一些概念

- HTTP
  - HTTP 是 ( 超文本传输协议 ) 的缩写 ( HyperText Transfer Protocol )
  - 超文本: 指 ( 传输的内容是超文本 - 是文字，图片，视频，超链接 的 混合体 ) -- html 就是常见的超文本
  - 扩展
    - URL 和 URI
      - URL: 强调 Location，表示 ----- 统一资源定位符
      - URI: 强调 Identifier，表示 --- 统一资源标识符
    - encodeURI 和 encodeURIComponent
      - encodeURI: 编码整个 url
      - encodeURIComponent: 编码 url 的参数部分，即 query 部分，主要用于对 url 中包含回调地址，对回调地址的处理用 encodeURIComponent
    - IP 地址 和 MAC 地址
      - 通过 IP 地址能找到 MAC 地址，从而找到具体的设备
    - 递归 和 迭代
      - 递归: a->b->c->b->a
      - 迭代: a->b b->a a->c c->a
    - 如何判断是几级域名
      - 有几个点就是几级域名: www.baidu.com.cn 一共有 3 个点，所以是 3 级域名

## (五) TCP/IP 协议

- 应用层 ---------- HTTP
- 传输层 ---------- TCP UDP
- 网络层 ---------- IP ICMP
- 数据链路层
- // 物理层

```
IP是高速公路
TCP是货车
HTTP时货物
```

## (六) TCP 报文

- TCP 报文 = TCP 首部 + TCP 数据部分
  - 序号: Seq
  - 确认号: Ack ---------- Ack = Seq + 1
  - 标志位
    - ACK: 只有 标志位 ACK=1 时，确认号 Ack 才有效
    - SYN: 发起一个链接
    - FIN: 释放一个链接

## (七) TCP 三次握手

- 1. 客户端 -> 服务端
  - 标志位 SYN=1，序号 Seq=x，的 ( 链接包 )
  - 客户端状态: CLOSED -> SYN_SENT
  - 标志位 SYN=1，表示建立链接
- 2. 服务端 -> 客户端
  - 标志位 SYN=1，序号 Seq=y，确认号 Ack=x+1，的 ( 确认包 )
  - 服务端状态: CLOSED -> SYN_RECEIVED
- 3. 客户端 -> 服务器
  - 标志位 ACK=1，序号 Seq=x+1，确认号 Ack=y+1，的 ( 确认包 )
  - 双方的状态: 都变成了 established

```
问题: 为什么需要第三次握手？
回答:
  - 1.第一次握手，服务端能确认: 客户端的发送能力正常，自己的接收能力正常
  - 2.第二次握手，客户端能确认: 服务端的接收发送能力正常，自己的发送接收能力正常 ---- 注意: ( 第二次握手 ) ( 服务端 ) ( 不能确认客户端的接收能力是否正常 )，所以需要第三次握手
  - 3.第三次握手，服务端能确认: 客户端的接收、发送能力，和服务端的接收、发送能力都是正常
总结:
  - 如果两次握手，服务端是没法确认客户端的接收能力是正常
  - 防止已失效的连接请求又传送到服务器端，因而产生错误
  - 为了实现可靠数据传输， TCP 协议的通信双方都必须维护一个序列号， 标识发送出去的数据包哪些已经被对方收到
  - 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
```

## (八) TCP 四次挥手

- 1. 客户端 -> 服务端
  - 标志位 FIN=1，序号 Seq=u，的 ( 释放包 )
  - 客户端状态: ESTABLISHED -> FIN_WAIT1
  - 表明的是: 客户端的报文发送完了，但是客户端还能 接收报文
- 2. 服务端 -> 客户端
  - 标志位: ACK=1，序号 Seq=v，确认号 Ack=u+1，的 ( 确认包 )
  - 服务端状态: ESTABLISHED 状态 => CLOSE_WAIT
- 3. 服务端 -> 客户端
  - 标志位 FIN=1，ACK=1，序号 Seq=w，确认号 Ack=u+1，的 ( 释放包 )
  - 服务端状态：CLOSEWAIT => LAST_ACK
  - 表明的是：主动方(服务端)的报文发送完了，但是主动方(服务端)还是可以接收报文
- 4. 客户端 -> 服务器
  - 标志位: ACK=1，序号 Seq=u+1，确认号 Ack=w+1 的 ( 确认包 )
  - 客户端状态：FIN_WAIT2 => TIME_WAIT

## (九) HTTP 常见的状态码

```
100 Continue 客户端应该继续请求，比如post请求就是分两段，header 和 data
101 Switching Protocols 升级协议，切换协议

200 ok
204 No Content 请求成功，但没有资源可以返回
206 Partial Content 范围请求

301 Moved Permanently 永久重定向，需要修改之前保存的书签
302 Found 临时重定向，不需要修改之前保存的书签
303 See Other 临时重定向，------------------------------- 应采用 GET 方法获取资源
304 Not Modified 资源未被修改 --------------------------- 用户协商缓存
307 Temporary Redirect 临时重定向，---------------------- 不需要从POST换成GET

400 Bad Request 错误的请求，存在错误语法
401 UnAuthorized 未授权
403 Forbidden 权限不够
404 Not Found 资源未找到，访问的地址不存在
405 Method Not Allowed 请求方法错误
408 Request Timeout 请求超时

500 Internet Server Error 服务端错误
502 Bad Gateway 网关错误
503 Service UnAvailable 服务哦过载
504 Gateway Timeout 网关超时
```

## (十) HTTP 的缺点

- 通信是明文，内容可能被 ---------- 窃听
- 不验证通信双方的身份，可能会遭遇 -- 伪装
- 无法验证报文的完整性，啃根会被 ---- 篡改
- 扩展
  - 加密的对象有哪些: 1.通信线路的加密 2.通信内容的加密

## (十一) HTTP 报文

- HTTP 报文 = 报文首部 + 空行 + 报文主体
  - 请求报文首部 = 请求行 ( 请求的方法 + URI + HTTP 版本 ) + 请求头
  - 响应报文首部 = 响应行 即 状态行 ( HTTP 版本 + 状态码 + 原因短语 ) + 响应头

## (十二) HTTPS

- HTTPS = HTTP + 加密 + 认证 + 完整性保护
- 是在 ( 应用层 ) 和 ( 传输层 ) 之间加了 ( SSL 层 )
- 加密方式
  - HTTPS 采用 ( 混合加密的方式 )，即 ( 对称加密 + 非对称加密 )
  - 交换密钥阶段: ------------ 使用非对称加密，安全得交换密钥 - 该密钥是对称加密通信时所需要的密钥，只有一个，双方共享
  - 建立通信，交换报文阶段: ---- 使用对称加密，进行通信，提升性能
- 数字证书认证机构的业务流程
  - 前置知识
    - 服务器: 有一对非对称加密的密钥: 一个公钥，一个私钥
    - 证书颁发机构: 也有一对非对称加密的密钥: 一个公钥，一个私钥，注意: 私钥是提前内置在浏览器中
  - 具体流程
    - 1. 服务器把自己的 ( 公钥 ) 向证书认证机构申请证书
    - 2. 证书颁发机构用自己的 ( 私钥 ) 对服务器的 ( 公钥 ) 进行数字签名，并生成 ( 公钥证书 ) ------ 公钥加密私钥解，私钥加密公钥解
    - 3. ( 服务器 ) 向 ( 客服端 ) 发送证书颁发机构颁发的 ( 公钥证书 )
    - 4. ( 客服端 ) 收到公钥证书后，利用内置在自己的 ( 证书颁发机构的公钥 ) 解密， (公钥证书中，证明服务器的公钥的真实性 )
    - 5. 如果是真实的服务的公钥证书，那么 ( 客户端就会用服务器的公钥加密之后在对称加密才会用到的密钥 ) 并发送给服务器
    - 6. 服务器收到 ( 加密后的信息后 ) 用自己的私钥 ( 解密 )，解密后服务端就获取到了 ( 对称加密的密钥了 )
    - 7. 接下来，通信双发就可以进行 ( 对称加密通信了 )，即可以建立通信，交换报文了
    - 总结: 服务器公钥 -> 给证书机构，机构用私钥加密服务器的公钥，生成公钥证书 -> 给服务器 -> 客户端 -> 客户端用内置的机构的公钥解机构私钥，获得服务器的公钥 -> 用服务的公钥加密对称加密时用到的密钥 -> 发给服务器，服务器用自己的私钥解，获得对称密钥 -> 之后就是对称加密通信

## (十三) HTTPS 通信工程 - SSL 握手过程

```
-> ClientHello

<- ServerHello
<- Certificate
<- ServerHelloDone

-> ClientKeyExchange
-> ChangeCipherSpec
-> Finished

<- ChangeCipherSpec
<- Finished

-> ApplicationData
<- ApplicationData
```

## (十三) HTTP 和 HTTPS 的默认端口

```
http 80 // 注意不是8080
https 443
```
