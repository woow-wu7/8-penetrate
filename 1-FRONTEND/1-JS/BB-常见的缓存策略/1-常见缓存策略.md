# 常见的缓存策略

- LRU 最近最少使用
- LFU 最不经常使用
- FIFO 先进先出

### (1) LRU 最新最少使用 - 强调访问时间

- LRU: Least recently used 最近最少使用
- 设计原则
  - 如果一个数据，在最近一段时间内没有被访问到，那么将来被访问的可能性也很小，也就是说，当 ( 缓存空间存满 ) 时，最不常用 ( 最近最少使用 ) 的数据将被 ( 淘汰 )
- 类比
  - 队列 ( 先进先出 ) + 最新使用的提前
- 案例
  - vue 中的 keep-alive 的缓存策略

```
LRU - Least recently used 最近最少使用
---

案例描述
1. 我们依次访问 ABCDBE 数据，内存能容纳的数据量就是3个
2. 当访问 ABC 后内存就满了
3. 我们继续访问 D 数据时，D在内存中不存在，A被移除，------------------ 此时内存为 BCD
4. 我们继续访问 B 数据时，B在内存中存在，B移动到最后面 --------------- 此时内存为 CDB
5. 我们继续访问 E 数据时，E在内存中不存在，C被移除 ------------------ 此时内存为 DBE

资料
https://juejin.cn/post/6862206197877964807
https://blog.51cto.com/sddai/3017058
```

### (2) LFU 最不经常使用 - 强调访问次数

- LFU: Least frequently used 最不经常使用

```
LFU - Least frequently used 最不经常使用
---

LFU
淘汰3 - 强调次数
1. 内存大小是 3，内存中存在 [1, 2, 3]，然后我们一次访问访问 2  1  2  1  2  3  4 
2. 当需要使用页面4时，内存块中存储着1、2、3，内存块中没有页面4，最后淘汰的是 3，因为一段时间内 3 被访问的次数最少
3. 因为在这段时间内，页面1被访问了2次，页面2被访问了3次，而页面3只被访问了1次，一段时间内被访问的次数最少
4. 所以最后是 [1, 2, 4]，在LFU最不经常使用算法中，位置不重要，访问的次数很重要


LRU
淘汰1 - 强调时间
1. 内存大小是 3，依次访问访问 2  1  2  1  2  3  4 
2. 21
    -> 第三次访问2，则内存变为12
    -> 第四次访问1，则内存变为21
    -> 第五次访问2，则内存变为12
    -> 第六次访问3，则内存变为123
    -> 第七次访问4，则内存变为234，淘汰1
```
