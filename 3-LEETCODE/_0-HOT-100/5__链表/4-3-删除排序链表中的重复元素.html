<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 83. 删除排序链表中的重复元素

      // 题目
      // 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

      // leetcode
      // 83. 删除排序链表中的重复元素 https://leetcode.cn/problems/remove-duplicates-from-sorted-list/

      /**
       * Definition for singly-linked list.
       * function ListNode(val, next) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.next = (next===undefined ? null : next)
       * }
       */
      /**
       * @param {ListNode} head
       * @return {ListNode}
       */

      // 对比
      // ( 删除一个节点 ) 剑指 Offer 18. 删除链表的节点 https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/
      // ( 删除多个节点 ) 203. 移除链表元素 https://leetcode.cn/problems/remove-linked-list-elements/
      // ( 存在重复的节点，就删除重复的靠后的节点 ) 83. 删除排序链表中的重复元素 https://leetcode.cn/problems/remove-duplicates-from-sorted-list/
      // ( 删除倒数第N个节点 - 滑动窗口 )  19. 删除链表的倒数第 N 个结点 https://leetcode.cn/problems/remove-nth-node-from-end-of-list/

      // 注意
      // - 本题不需要借助 dummy 节点，可以直接从head节点开始遍历

      // 方法 1
      var deleteDuplicates = function (head) {
        let dummy = (list = new ListNode(null)); // 我们这里还是使用了dummy节点，因为所有删除的题目都保持一致比较好，就是用前一个节点来操作
        dummy.next = head;

        while (list.next && list.next.next) {
          if (list.next.val === list.next.next.val) {
            list.next = list.next.next; // delete
          } else {
            list = list.next; // move backward.
          }
        }

        return dummy.next;
      };

      // ------- ------- ------- ------- ------- ------- ------- ------- ------- ------- -------
      // ------- ------- ------- ------- ------- ------- ------- ------- ------- ------- -------
      // 方法 2
      var deleteDuplicates = function (head) {
        if (!head) return head; // 边界 - 空链表，只有一个节点的链表

        let list = head; // 缓存头节点

        while (list.next) {
          if (list.val === head.next.val) {
            // 注意：
            // - 这里 两个节点相等后，修改指针指向后，本轮循环就完成了。
            // - 不能往后移动指针，因为当前节点还要和修改指针后的下一个节点比较，只有不想等时才移动指针
            list.next = list.next.next;
          } else {
            list = list.next; // 后移指针
          }
        }

        return head; // 返回头节点
      };
    </script>
  </body>
</html>
