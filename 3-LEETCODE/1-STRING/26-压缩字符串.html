<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 443. 压缩字符串

      // 题目
      // 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：
      // 如果这一组长度为 1 ，则将字符追加到 s 中。
      // 否则，需要向 s 追加字符，后跟这一组的长度。
      // 压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。
      // 请在 修改完输入数组后 ，返回该数组的新长度。
      // 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。

      // 示例 1：
      // 输入：chars = ["a","a","b","b","c","c","c"]
      // 输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
      // 解释："aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。

      // 示例 2：
      // 输入：chars = ["a"]
      // 输出：返回 1 ，输入数组的前 1 个字符应该是：["a"]
      // 解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。

      // 示例 3：
      // 输入：chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
      // 输出：返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
      // 解释：由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。

      // 思路
      // - 双指针
      //  - i 表示当前成员
      //  - j 表示连续值相等的成员的右边界
      var compress = function (chars) {
        let i = 0;
        let j = i + 1;

        let res = "";

        while (j <= chars.length) {
          if (chars[j] === chars[i]) {
            j++; // 找到相同的右边界
          } else {
            const cur = j - i > 1 ? `${chars[i]}${j - i}` : `${chars[i]}`; // 结果统计
            res = res + cur;

            // 完成统计后，后移指针，进行下一轮寻找相同的成员
            i = j;
            j = i + 1;
          }
        }

        // 追加
        for (let i = 0; i < res.length; i++) {
          chars[i] = res[i];
        }

        // 结果
        return res.length;
      };
    </script>
  </body>
</html>
