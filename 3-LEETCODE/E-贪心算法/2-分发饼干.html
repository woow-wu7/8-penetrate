<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 455. 分发饼干

      // 题目
      // 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
      // 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

      // 示例 1:
      // 输入: g = [1,2,3], s = [1,1]
      // 输出: 1
      // 解释:
      // 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
      // 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
      // 所以你应该输出1。

      // 示例 2:
      // 输入: g = [1,2], s = [1,2,3]
      // 输出: 2
      // 解释:
      // 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
      // 你拥有的饼干数量和尺寸都足以让所有孩子满足。
      // 所以你应该输出2.

      /**
       * @param {number[]} g
       * @param {number[]} s
       * @return {number}
       */

      // leetcode
      // 455. 分发饼干 https://leetcode.cn/problems/assign-cookies/

      // 思路
      // 贪心算法
      // - 贪心算法 ( 局部最优 能推出 全局最优 )
      // - 把最大的饼干 分给 胃口最大的孩子
      // - 或者说把最小的饼干 分给 胃口最小的孩子

      var findContentChildren = function (g, s) {
        let [count, gi, si] = [0, 0, 0]; // 可以喂饱孩子的数量，孩子胃口，饼干大小
        // let count = gi = si = 0 这样声明也是可以的

        s.sort((a, b) => a - b); // 先排序，升序
        g.sort((a, b) => a - b);

        while (si < s.length && gi < g.length) {
          // 饼干大小 >= 孩子胃口
          if (s[si] >= g[gi]) {
            count++;
            gi++;
            si++;
          }
          // 饼干大小 < 孩子胃口，则遍历下一个更大的饼干
          else {
            si++;
          }
        }

        return count;
      };
    </script>
  </body>
</html>
