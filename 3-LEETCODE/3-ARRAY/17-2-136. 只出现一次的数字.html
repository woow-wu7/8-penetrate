<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 136. 只出现一次的数字

      // 题目
      // 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
      // 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

      // 示例 1 ：
      // 输入：nums = [2,2,1]
      // 输出：1

      // 示例 2 ：
      // 输入：nums = [4,1,2,1,2]
      // 输出：4
      // 示例 3 ：

      // 输入：nums = [1]
      // 输出：1

      // 提示：
      // 1 <= nums.length <= 3 * 104
      // -3 * 104 <= nums[i] <= 3 * 104
      // 除了某个元素只出现一次以外，其余每个元素均出现两次。

      /**
       * @param {number[]} nums
       * @return {number}
       */

      // leetcode
      // https://leetcode.cn/problems/single-number/

      // 对比
      // - 136. 只出现一次的数字 https://leetcode.cn/problems/single-number/
      // - 387. 字符串中的第一个唯一字符  https://leetcode.cn/problems/first-unique-character-in-a-string/

      // 方案1
      // - 全都是数字，可以用 ( 异或位运算符^ )
      // n^n = 0
      // n^0 = n
      // a ^ b ^ c <=> a ^ c ^ b
      // 注意: ^ 用于number类型的运算，字符的二进制没法直观计算
      var singleNumber = function (nums) {
        let res = 0;
        for (let i = 0; i < nums.length; i++) {
          res = res ^ nums[i];
        }
        return res;
      };

      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // 方案2
      // - map + 两次遍历
      var singleNumber = function (nums) {
        const map = new Map();
        for (let i = 0; i < nums.length; i++) {
          const cur = nums[i];
          if (!map.has(cur)) {
            map.set(cur, 1);
          } else {
            map.set(cur, map.get(cur) + 1);
          }
        }
        for (let j = 0; j < nums.length; j++) {
          if (map.get(nums[j]) === 1) return nums[j];
        }
      };
    </script>
  </body>
</html>
