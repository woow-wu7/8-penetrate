<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 674. 最长连续递增序列

      // 题目
      // 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
      // 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

      // 示例 1：
      // 输入：nums = [1,3,5,4,7]
      // 输出：3
      // 解释：最长连续递增序列是 [1,3,5], 长度为3。
      // 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。

      // 示例 2：
      // 输入：nums = [2,2,2,2,2]
      // 输出：1
      // 解释：最长连续递增序列是 [2], 长度为1。

      // leetcode
      // 674. 最长连续递增序列 https://leetcode.cn/problems/longest-continuous-increasing-subsequence/

      /**
       * @param {number[]} nums
       * @return {number}
       */

      // 对比
      // 300. 最长递增子序列 ----- ( 动态规划 )  https://leetcode.cn/problems/longest-increasing-subsequence/
      // 674. 最长连续递增序列 --- ( 连续 ) https://leetcode.cn/problems/longest-continuous-increasing-subsequence/
      // 3. 无重复字符的最长子串 -- ( 滑动窗口 + Set ) https://leetcode.cn/problems/longest-substring-without-repeating-characters/
      // 剑指 Offer 48. 最长不含重复字符的子字符串 https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/

      var findLengthOfLCIS = function (nums) {
        let max = 1; // 最终的 ( 最长连续递增子序列的 长度 )，初始值是1，是为了满足 nums.length = 1 的情况
        let temp = 1; // 每段连续递增子序列的长度

        for (let i = 1; i < nums.length; i++) {
          if (nums[i] > nums[i - 1]) {
            temp++;
            if (temp > max) max = temp;
          } else {
            // 不满足连续递增了后，从新开始计算后面的连续递增
            temp = 1;
          }
        }

        return max;
      };
    </script>
  </body>
</html>
