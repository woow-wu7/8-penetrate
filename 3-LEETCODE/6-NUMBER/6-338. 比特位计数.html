<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 338. 比特位计数

      // 题目
      // 给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

      // 示例 1：
      // 输入：n = 2
      // 输出：[0,1,1]
      // 解释：
      // 0 --> 0
      // 1 --> 1
      // 2 --> 10

      // 示例 2：
      // 输入：n = 5
      // 输出：[0,1,1,2,1,2]
      // 解释：
      // 0 --> 0
      // 1 --> 1
      // 2 --> 10
      // 3 --> 11
      // 4 --> 100 ----- 偶数 和 偶数/2 的1的个数是相等的
      // 5 --> 101 ----- 奇数比偶数多一个 1

      // 提示：
      // 0 <= n <= 105

      // 进阶：
      // 很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
      // 你能不使用任何内置函数解决此问题吗？

      /**
       * @param {number} n
       * @return {number[]}
       */

      // leetcode
      // https://leetcode.cn/problems/counting-bits/

      // 思路
      // - 通过观察我们知道
      // - 偶数: ( 偶数的1的个数  ) 比该偶数 ( 前一个奇数的1的个数 ) 多 ( 1 )
      // - 奇数: ( 奇数的1的个数  ) 和 ( 当前奇数/2 的1个数 ) 多 ( 1 )

      var countBits = function (n) {
        const res = [0]; // 因为 0 <= n <= 105，所以n=0必然存在，是0

        // 注意边界，从1开始，可以取到n
        for (let i = 1; i <= n; i++) {
          // 奇数
          // (  i & 1 ) === i%2，性能比%好
          if ((i & 1) === 1) {
            res[i] = res[i - 1] + 1;
          }
          // 偶数
          else {
            res[i] = res[i / 2];
          }
        }

        return res;
      };
    </script>
  </body>
</html>
