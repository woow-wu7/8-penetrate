<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 287. 寻找重复数

      // 题目
      // 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
      // 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
      // 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

      // 示例 1：
      // 输入：nums = [1,3,4,2,2]
      // 输出：2

      // 示例 2：
      // 输入：nums = [3,1,3,4,2]
      // 输出：3
      //

      // 提示：
      // 1 <= n <= 105
      // nums.length == n + 1
      // 1 <= nums[i] <= n
      // nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次

      // 进阶：
      // 如何证明 nums 中至少存在一个重复的数字?
      // 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？

      /**
       * @param {number[]} nums
       * @return {number}
       */

      // leetcode
      // https://leetcode.cn/problems/find-the-duplicate-number/

      // 对比
      // 都是对环入口的考核
      // 剑指 Offer II 022. 链表中环的入口节点  https://leetcode.cn/problems/linked-list-cycle-ii/
      // 287. 寻找重复数 https://leetcode.cn/problems/find-the-duplicate-number/

      // 思路
      // - 快慢指针
      // - 二分法
      // - map

      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // 方法 1
      // 快慢指针
      // 1
      // - 因为: ( 数组长度是 n + 1 )，而数组每个成员值的范围是 ( [1, n] ) 之间
      // - 所以: 无论我们我们怎么把 ( 数组每个值作为下标，都不会越界 )
      // 2
      // - 我们可以把 ( 唯一重复的值 ) 看作是 ( 环形链表 ) 的入口，则就转化成了 ( 寻找环形链表的入口的类似题了 )
      var findDuplicate = function (nums) {
        let fast = 0;
        let slow = 0;

        fast = nums[fast];
        fast = nums[fast];
        slow = nums[slow]; // 先要将 快慢指针 走一次，不然  while (fast !== slow) 直接就不成了，因为 fast=0 slow=0

        while (fast !== slow) {
          fast = nums[fast];
          fast = nums[fast]; // 以为数组中任何一个成员的值作为下标，都不会越界，以此来模拟fast走两次
          slow = nums[slow];
        }

        // 1
        // 环
        // 当 fast === slow 时，说明有环，下一步就是找环入口，将 fast 重置
        fast = 0;

        // 2
        // 环的入口
        while (fast !== slow) {
          fast = nums[fast];
          slow = nums[slow]; // 找入口时，速度是相同的
        }

        // 再次相遇时，fast和slow相等，就是入口，返回fast或slow都可以
        return slow;
      };

      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // 方法 2
      // 二分法

      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------
      // 方法 3
      // map
      var findDuplicate = function (nums) {
        const map = new Map();
        for (let i = 0; i < nums.length; i++) {
          const target = nums[i];
          if (!map.has(target)) {
            map.set(target, 1);
          } else {
            map.set(target, map.get(target) + 1);
          }
        }
        for (let j = 0; j < nums.length; j++) {
          if (map.get(nums[j]) > 1) return nums[j];
        }
      };
    </script>
  </body>
</html>
