<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 392. 判断子序列

      // 题目
      // 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
      // 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
      // 进阶：
      // 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

      // leetcode
      // https://leetcode.cn/problems/is-subsequence/

      // 示例 1：
      // 输入：s = "abc", t = "ahbgdc"
      // 输出：true

      // 示例 2：
      // 输入：s = "axc", t = "ahbgdc"
      // 输出：false

      /**
       * @param {string} s
       * @param {string} t
       * @return {boolean}
       */

      // 双指针 教程
      // https://www.bilibili.com/video/BV19f4y197yS/?spm_id_from=333.999.0.0&vd_source=a8374ac38c77856369542fc154a1e043

      // 方法
      // - 双指针
      // - 原理
      // - 1. p1指针指 向 子序列 开始位置；p2指针 指向 s 开始位置
      // - 2. 两个串 都往后遍历，如果相等，则p1p2分别都后移
      // - 3. 当 任意一个串遍历完，如果 p1 并未遍历完的话，就不是 子序列
      
      var isSubsequence = function (s, t) {
        let p1 = 0;
        let p2 = 0; // 两个指针

        if (!s) return true;

        // 遍历结束条件，s和t 任意一个遍历完
        while (p1 < s.length && p2 < t.length) {
          if (s[p1] === t[p2]) {
            p1++;
            p2++;
          } else {
            p2++;
          }
        }

        // 在任意一个遍历完的情况下，如果 p1 === s.length 说明已经匹配到了
        // 因为: p1 已经遍历到 s 的串末尾的下一位了，说明最后肯定 s.length -1 有匹配到字符
        // 注意: ！！！！！！ 是 s.length 位置，不是 s.length - 1 位置。！！！！！！
        if (p1 === s.length) return true;
        return false;
      };
    </script>
  </body>
</html>
