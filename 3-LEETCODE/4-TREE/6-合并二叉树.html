<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 617. 合并二叉树

      // 题目
      // 给你两棵二叉树： root1 和 root2 。
      // 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。
      // 你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；
      // 否则，不为 null 的节点将直接作为新二叉树的节点。
      // 返回合并后的二叉树。
      // 注意: 合并过程必须从两个树的根节点开始。

      // 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
      // 输出：[3,4,5,5,4,null,7]

      // 输入：root1 = [1], root2 = [1,2]
      // 输出：[2,2]

      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root1
       * @param {TreeNode} root2
       * @return {TreeNode}
       */

      // leetcode
      // 617. 合并二叉树 https://leetcode.cn/problems/merge-two-binary-trees/

      // 对比
      // 88. 合并两个有序数组 https://leetcode.cn/problems/merge-sorted-array/
      // 617. 合并二叉树 https://leetcode.cn/problems/merge-two-binary-trees/
      // 25. 合并两个排序的链表 https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/

      // 思路
      // 1. 选取 root1 作为要合并后的操作树
      //    - 当然也可以新建一棵全新的树，只不过那样要额外的空间
      //    - 我们直接修改 root1，选root2同理
      // 2. 深度优先遍历 - 前序遍历
      // 3. 左右子树同步

      var mergeTrees = function (root1, root2) {
        // 递归结束条件
        if (!root1) return root2;
        if (!root2) return root1;

        // 前序遍历，根左右
        root1.val = root1.val + root2.val; // 两个节点都存在，则相加
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);

        // 最终结果
        return root1;
      };
    </script>
  </body>
</html>
