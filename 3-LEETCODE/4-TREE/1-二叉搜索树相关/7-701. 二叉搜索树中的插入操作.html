<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 701. 二叉搜索树中的插入操作

      // 题目
      // 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
      // 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

      // 示例 1：
      // 输入：root = [4,2,7,1,3], val = 5
      // 输出：[4,2,7,1,3,5]
      // 解释：另一个满足题目要求可以通过的树是：

      // 示例 2：
      // 输入：root = [40,20,60,10,30,50,70], val = 25
      // 输出：[40,20,60,10,30,50,70,null,null,25]

      // 示例 3：
      // 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
      // 输出：[4,2,7,1,3,5]

      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root
       * @param {number} val
       * @return {TreeNode}
       */

      // leetcode
      // https://leetcode.cn/problems/insert-into-a-binary-search-tree/

      // 思路
      // - ( 二叉搜索树 ) 的 ( 插入 ) 操作，都是可以是插入到 ( 叶子节点 )

      var insertIntoBST = function (root, val) {
        // 当遍历到叶子节点时，直接向上返回需要插入的节点
        if (!root) return new TreeNode(val);

        if (val < root.val) root.left = insertIntoBST(root.left, val);
        if (val > root.val) root.right = insertIntoBST(root.right, val);

        return root;
      };
    </script>
  </body>
</html>
