<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 46. 全排列

      // 题目
      // 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

      // 示例 1：
      // 输入：nums = [1,2,3]
      // 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

      // 示例 2：
      // 输入：nums = [0,1]
      // 输出：[[0,1],[1,0]]
      // 示例 3：
      // 输入：nums = [1]
      // 输出：[[1]]

      // leetcode
      // https://leetcode.cn/problems/permutations/

      /**
       * @param {number[]} nums
       * @return {number[][]}
       */

      // 1
      // 注意
      // 排列 和 组合 的区别？

      // 2
      // 回溯模版
      /* ```1
        result = [];
        let backTrack = function(nums,track){
          if(递归终止条件){
            收集结果
            return; // 回溯算法的递归函数通常没有返回值
          }
          for(集合元素){
            处理节点
            递归函数 - backTrack
            回溯操作 - 撤销处理节点的情况
          }
        }
      ```*/

      // 3
      // 回溯算法
      // - 排列 组合 子集 切割 棋盘

      var permute = function (nums) {
        const res = [];

        // dfs
        // - path -> 表示已经使用的数字
        // - used -> 可以使用的数字
        function dfs(path, used) {
          // 1 递归结束条件 收集结果
          if (path.length === nums.length) {
            // 递归结束条件: 抽象为树后，在叶子节点收集结果，也就是 ( 树的深度===nums.length ) 时
            res.push([...path]); // 收集结果，这里作浅拷贝，防止引用出错
            return;
          }

          // 2
          // 处理节点
          // 递归
          // 回溯
          for (let i = 0; i < used.length; i++) {
            dfs(
              path.concat(used[i]), // 添加i
              used.slice(0, i).concat(used.slice(i + 1)) // 剔除i
            );
          }
        }

        dfs([], nums);

        return res;
      };
    </script>
  </body>
</html>
